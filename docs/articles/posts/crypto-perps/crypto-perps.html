<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.56">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Josh Pearlson">
<meta name="dcterms.date" content="2026-02-05">

<title>Perpetual Futures: The Market for Leverage – Josh Pearlson</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../">
<link href="../../../media/jcp_logo2.png" rel="icon" type="image/png">
<script src="../../../site_libs/quarto-html/quarto.js"></script>
<script src="../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f"
  ],
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../../css/header.css">
<link rel="stylesheet" href="../../../css/posts.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../../../index.html" class="navbar-brand navbar-brand-logo">
    <img src="../../../media/jcp_logo3.png" alt="" class="navbar-logo">
    </a>
    <a class="navbar-brand" href="../../../index.html">
    <span class="navbar-title">Josh Pearlson</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../../articles/blog.html"> 
<span class="menu-text">Articles</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../projects/projects.html"> 
<span class="menu-text">Projects</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../aboutPage/about.html"> 
<span class="menu-text">About</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Perpetual Futures: The Market for Leverage</h1>
                                <div class="quarto-categories">
                <div class="quarto-category">Derivatives</div>
                <div class="quarto-category">Crypto</div>
                <div class="quarto-category">Finance</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Josh Pearlson </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">February 5, 2026</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<p>The derivative that never expires, the funding rate that never sleeps, and the incentives that quietly shape crypto volatility.</p>
<hr>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="../../../media/perps_image.png" class="img-fluid figure-img"></p>
<figcaption>Perps</figcaption>
</figure>
</div>
<p>Perpetual futures (“perps”) are the product that quietly won crypto. They look like futures, trade like futures, and offer clean linear exposure with leverage. But they never expire, and that single design choice changes everything: price anchoring, liquidity concentration, and a new market for leverage built out of funding rates.</p>
<p>This is an introductory tour of perps: what they are, why they are not really futures, how funding works, and how the mechanics create both elegance and chaos.</p>
<section id="why-perps-exist" class="level2">
<h2 class="anchored" data-anchor-id="why-perps-exist">Why perps exist</h2>
<p>Traditional futures are a stack of contracts by maturity: March, June, September, and so on. That structure creates three annoying problems:</p>
<ol type="1">
<li><strong>Liquidity fragmentation.</strong> Each maturity has its own order book.</li>
<li><strong>Roll friction.</strong> You must close one contract and open the next, paying spreads and fees.</li>
<li><strong>Basis noise.</strong> PnL can swing because the futures price decouples from spot, even if the underlying barely moves.</li>
</ol>
<p>Perps are the answer. They eliminate expiry and roll friction while preserving linear leveraged exposure. All liquidity collapses into a single book. You can hold a position as long as you want. But if there is no expiry, how does the price stay tethered to spot?</p>
<p>That is where funding rates come in.</p>
</section>
<section id="what-is-a-perpetual-future" class="level2">
<h2 class="anchored" data-anchor-id="what-is-a-perpetual-future">What is a perpetual future?</h2>
<p>A perp is a margined, linear derivative on an underlying index with <strong>no maturity</strong>. It is marked to an external index (e.g., a composite of spot prices across exchanges), and it stays close to that index via <strong>funding payments</strong> between longs and shorts.</p>
<p>Key features:</p>
<ul>
<li><strong>No maturity.</strong> The position can be held indefinitely.</li>
<li><strong>Continuous mark to index.</strong> PnL is based on changes in the index price.</li>
<li><strong>Funding transfers.</strong> Periodic payments between longs and shorts push the perp price toward spot.</li>
<li><strong>Central clearing.</strong> The exchange manages margin, liquidations, and an insurance fund.</li>
<li><strong>Single deep liquidity pool.</strong> One order book, one main price.</li>
</ul>
</section>
<section id="why-it-is-not-really-a-future" class="level2">
<h2 class="anchored" data-anchor-id="why-it-is-not-really-a-future">Why it is not really a future</h2>
<p>Futures are defined by a fixed expiry and a convergence mechanism. At expiration the futures price becomes the spot price. However, perps do not converge because they never expire.</p>
<p>Instead, perps rely on <strong>economic pressure</strong> rather than <strong>calendar convergence</strong>. When perp price drifts above spot, longs pay shorts. That payment makes long positions more expensive and short positions more attractive, pulling the perp price down. When perp trades below spot, the opposite happens.</p>
<p>So a perp is less like a future and more like a <strong>synthetic, never-ending forward</strong> where you rent the position via a funding fee. I would also like to formally offer a suggestion of changing the name of these so called perpetual futures to perpetual forwards, but I digress.</p>
</section>
<section id="the-brilliance-of-funding-rates" class="level2">
<h2 class="anchored" data-anchor-id="the-brilliance-of-funding-rates">The brilliance of funding rates</h2>
<p>Funding is the trick that replaces expiration. It is also the mechanism that creates a market for leverage itself!</p>
<p>At a high level:</p>
<ul>
<li>If the perp trades <strong>above</strong> spot, <strong>longs pay shorts</strong>.</li>
<li>If the perp trades <strong>below</strong> spot, <strong>shorts pay longs</strong>.</li>
</ul>
<p>Each exchange uses its own formula, but most look like some variation of:</p>
<p>Most exchanges use some variation of this formula:</p>
<p><span class="math display">\[
\begin{aligned}
    \text{Funding Rate} &amp;\approx \text{Clamp}\left(\frac{\text{Perp Price} - \text{Index Price}}{\text{Index Price}} + \text{Interest Component}\right)
\end{aligned}
\]</span></p>
<p>Let’s break this down piece by piece.</p>
<p>The first term, <span class="math inline">\(\frac{\text{Perp Price} - \text{Index Price}}{\text{Index Price}}\)</span>, is the <strong>premium</strong> (or discount). It measures how far the perp has drifted from spot as a percentage. If the perp is trading at <span class="math inline">\(\$50,500\)</span> and spot is at <span class="math inline">\(\$50,000\)</span>, the premium is:</p>
<p><span class="math display">\[
\begin{aligned}
    \text{Premium} &amp;= \frac{50,500 - 50,000}{50,000} = \frac{500}{50,000} = 0.01 = 1\%
\end{aligned}
\]</span></p>
<p>The second term is the interest component, which reflects the cost of capital. In traditional derivatives, this matters because one currency might have higher rates than another. In crypto, this is usually tiny, often effectively zero, because both sides are collateralized in the same asset (e.g., USDC or BTC). Most exchanges set it to something like <span class="math inline">\(0.01\%\)</span> or less per funding period.</p>
<p>The <strong>Clamp</strong> function caps the funding rate at some maximum to prevent extreme transfers during volatility. Different exchanges use different caps (commonly <span class="math inline">\(\pm 0.75\%\)</span> to <span class="math inline">\(\pm 2\%\)</span> per funding period). Without this, a flash crash could trigger enormous funding payments.</p>
<p><strong>Funding periods</strong> are typically <strong>8 hours</strong> on most exchanges (three times per day at 00:00, 08:00, and 16:00 UTC). Some use 1 hour. The rate is annualized in some displays but applied per period.</p>
<section id="funding-math-in-plain-english" class="level3">
<h3 class="anchored" data-anchor-id="funding-math-in-plain-english">Funding math in plain English</h3>
<p>Now that we understand the rate calculation, let’s talk about actual payments. If you hold a perp position with notional value <span class="math inline">\(N\)</span> and the funding rate per period is <span class="math inline">\(f\)</span>, your funding payment is simply:</p>
<p><span class="math display">\[
\begin{aligned}
    \text{Funding Payment} = N \times f
\end{aligned}
\]</span></p>
<p>Let’s work through a concrete example. Suppose:</p>
<ul>
<li><strong>BTC perp price:</strong> <span class="math inline">\(\$50,000\)</span></li>
<li><strong>Position size:</strong> <span class="math inline">\(0.5\)</span> BTC (you are long)</li>
<li><strong>Notional:</strong> <span class="math inline">\(N = 0.5 \times 50,000 = \$25,000\)</span></li>
<li><strong>Funding rate:</strong> <span class="math inline">\(0.01\%\)</span> per 8 hours <span class="math inline">\(= 0.0001\)</span></li>
</ul>
<p>The funding payment is:</p>
<p><span class="math display">\[
\begin{aligned}
    \text{Payment} &amp;= 25,000 \times 0.0001 \\
    &amp;= \$2.50
\end{aligned}
\]</span></p>
<p>If you are long and funding is positive (meaning perp &gt; spot), <strong>you pay <span class="math inline">\(\$2.50\)</span></strong> to shorts every 8 hours. If you are short, <strong>you receive <span class="math inline">\(\$2.50\)</span></strong> from longs. Three funding periods per day means this could cost you <span class="math inline">\(\$7.50\)</span> daily, or about <span class="math inline">\(\$2,738\)</span> per year on a <span class="math inline">\(\$25,000\)</span> position, roughly <span class="math inline">\(11\%\)</span> annually.</p>
<p>Of course, funding rates fluctuate. They can go negative (shorts pay longs), near-zero during calm markets, or spike to extreme levels during mania. During the 2021 bull run, BTC perp funding occasionally exceeded <span class="math inline">\(0.1\%\)</span> per 8 hours, more than <span class="math inline">\(100\%\)</span> annualized.</p>
<p>That tiny number is the <strong>price of leverage</strong>. It is the rent you pay to hold linear exposure with no expiry. And just like rent, it adds up if you are not paying attention.</p>
</section>
<section id="the-market-for-leverage" class="level3">
<h3 class="anchored" data-anchor-id="the-market-for-leverage">The market for leverage</h3>
<p>Here is where it gets interesting. Funding rates are not set by the exchange, they emerge from <strong>market positioning</strong>. They respond to demand for leverage in real time:</p>
<ul>
<li><strong>When everyone wants to be long</strong> (bullish sentiment, FOMO, momentum), the perp price rises above spot. Funding goes positive. <strong>Longs pay shorts</strong>. Being levered long becomes expensive.</li>
<li><strong>When everyone wants to be short</strong> (bearish sentiment, panic, hedging), the perp price falls below spot. Funding goes negative. <strong>Shorts pay longs</strong>. Being levered short becomes expensive.</li>
</ul>
<p>This is the market’s self-balancing mechanism. It does not remove leverage demand, it <strong>prices it</strong>.</p>
<p>Think about the incentives this creates. If funding is extremely positive, you get paid to short. If it is extremely negative, you get paid to go long. This naturally attracts contrarian traders who fade the crowd, which pulls the perp price back toward spot.</p>
<p>It is a brilliantly simple equilibrium: the more one-sided the market becomes, the more expensive it is to be on that side, and the more you get paid to take the other side.</p>
<p>If you want to be levered long in a euphoric market, you will pay a daily tax. If you want to be levered short into a panic, you will pay instead. Either way, <strong>funding is the toll booth for leverage</strong>.</p>
</section>
</section>
<section id="how-leverage-actually-works-in-perps" class="level2">
<h2 class="anchored" data-anchor-id="how-leverage-actually-works-in-perps">How leverage actually works in perps</h2>
<p>Perps are margined instruments, meaning you do not need to put up the full value of your position. You post collateral (initial margin), and the exchange lets you control a larger notional position. This is leverage in action.</p>
<p>The math is straightforward. Let:</p>
<ul>
<li><span class="math inline">\(P\)</span> = perp price</li>
<li><span class="math inline">\(Q\)</span> = position size (in coins or contracts)</li>
<li><span class="math inline">\(N = P \times Q\)</span> = notional value of your position</li>
<li><span class="math inline">\(M\)</span> = margin you posted</li>
</ul>
<p>Then leverage is simply:</p>
<p><span class="math display">\[
\begin{aligned}
    \text{Leverage} = \frac{N}{M}
\end{aligned}
\]</span></p>
<section id="a-worked-example" class="level3">
<h3 class="anchored" data-anchor-id="a-worked-example">A worked example</h3>
<p>Suppose you want to go long BTC perps:</p>
<ul>
<li><strong>BTC perp price:</strong> <span class="math inline">\(\$50,000\)</span></li>
<li><strong>Position size:</strong> <span class="math inline">\(0.2\)</span> BTC</li>
<li><strong>Notional:</strong> <span class="math inline">\(N = 0.2 \times 50,000 = \$10,000\)</span></li>
<li><strong>Margin posted:</strong> <span class="math inline">\(M = \$1,000\)</span></li>
</ul>
<p>Your leverage is:</p>
<p><span class="math display">\[
\begin{aligned}
    \text{Leverage} = \frac{10,000}{1,000} = 10\times
\end{aligned}
\]</span></p>
<p>Now, if BTC moves up by <span class="math inline">\(1\%\)</span>, your position gains <span class="math inline">\(1\%\)</span> of the notional value:</p>
<p><span class="math display">\[
\begin{aligned}
    \text{PnL} = N \times 1\% = 10,000 \times 0.01 = \$100
\end{aligned}
\]</span></p>
<p>That <span class="math inline">\(\$100\)</span> gain on a <span class="math inline">\(\$1,000\)</span> margin is a <strong>10% return on your capital</strong>. Your leverage amplified a <span class="math inline">\(1\%\)</span> market move into a <span class="math inline">\(10\%\)</span> portfolio move.</p>
<p>Of course, this works in reverse. A <span class="math inline">\(1\%\)</span> drop becomes a <span class="math inline">\(-10\%\)</span> loss. A <span class="math inline">\(5\%\)</span> drop is <span class="math inline">\(-50\%\)</span>. And at <span class="math inline">\(-10\%\)</span>, your margin is completely wiped out, which brings us to the cliff edge.</p>
</section>
<section id="liquidation-and-the-cliff-edge" class="level3">
<h3 class="anchored" data-anchor-id="liquidation-and-the-cliff-edge">Liquidation and the cliff edge</h3>
<p>Leverage is powerful, but it comes with a hard stop: <strong>liquidation</strong>. Exchanges enforce a <strong>maintenance margin</strong>, a minimum equity level you must maintain. If your position loses enough that your remaining equity falls below this threshold, the exchange forcibly closes your position at market prices.</p>
<p>Why? Because if they let you go negative, the exchange would be on the hook for your losses. Liquidations protect the exchange and the counterparties.</p>
<p>Ignoring funding costs and fees for a moment, the rough liquidation threshold for a long position is:</p>
<p><span class="math display">\[
\begin{aligned}
    \text{Liquidation Move} \approx -\frac{1}{\text{Leverage}}
\end{aligned}
\]</span></p>
<p>At <strong>10x leverage</strong>, a <strong>-10% move</strong> can wipe out your margin and trigger liquidation. At <strong>50x leverage</strong>, it takes just <strong>-2%</strong>. At <strong>100x</strong>, a <strong>-1%</strong> move is game over.</p>
<p>In reality, funding payments and trading fees eat into your margin buffer over time, so the actual safe range is tighter than the simple formula suggests. If you are paying positive funding three times a day, that margin is slowly bleeding out even if price does not move.</p>
</section>
<section id="the-cascade-effect" class="level3">
<h3 class="anchored" data-anchor-id="the-cascade-effect">The cascade effect</h3>
<p>Here is where perps can amplify volatility. Liquidations are not voluntary closes, they are <strong>forced market sells</strong> (for longs) or <strong>forced market buys</strong> (for shorts) that hit the order book instantly.</p>
<p>When price starts dropping and highly levered longs get liquidated, their forced selling pushes price lower, triggering more liquidations, creating more selling pressure, and so on. This is a <strong>liquidation cascade</strong>, and it is why you sometimes see brutal intraday moves in crypto that blow past technical levels and recover just as fast.</p>
<p>The same happens in reverse when shorts get squeezed. Forced buy-backs push price higher, liquidating more shorts, creating more buy pressure, rinse and repeat.</p>
<p>This is why perps can create fast, non-linear price action that looks nothing like spot. It is not just about the underlying asset moving, it is about leverage unwinding in real time.</p>
</section>
</section>
<section id="the-good-the-bad-and-the-weird" class="level2">
<h2 class="anchored" data-anchor-id="the-good-the-bad-and-the-weird">The good, the bad, and the weird</h2>
<section id="what-perps-solve" class="level3">
<h3 class="anchored" data-anchor-id="what-perps-solve">What perps solve</h3>
<ul>
<li><strong>No maturity, no roll.</strong> You never pay to roll a contract.</li>
<li><strong>Single liquidity pool.</strong> Liquidity concentrates, spreads tighten.</li>
<li><strong>Clean linear exposure.</strong> PnL tracks the underlying move (plus funding).</li>
<li><strong>Global access.</strong> Retail can access leverage in seconds.</li>
</ul>
</section>
<section id="unintended-effects" class="level3">
<h3 class="anchored" data-anchor-id="unintended-effects">Unintended effects</h3>
<ul>
<li><strong>Funding becomes a tradeable signal and tax.</strong> Traders fade extremes, or farm funding in neutral strategies.</li>
<li><strong>Reflexive leverage cycles.</strong> Positive funding encourages shorting, negative funding encourages longing, feeding cyclical positioning.</li>
<li><strong>Liquidation cascades.</strong> Forced liquidations can accelerate moves and create gaps.</li>
<li><strong>Exchange risk is concentrated.</strong> Perps are centrally cleared; you are exposed to the exchange.</li>
</ul>
<p>There is also <strong>ADL (auto-deleveraging)</strong>, a last-resort mechanism some exchanges use to reduce risk when liquidations fail. It is rare in normal markets, but it is part of the system design and worth knowing exists.</p>
</section>
</section>
<section id="a-simple-mental-model" class="level2">
<h2 class="anchored" data-anchor-id="a-simple-mental-model">A simple mental model</h2>
<p>Think of a perp as:</p>
<ul>
<li>A spot-like exposure</li>
<li>Plus an embedded funding lease</li>
<li>Settled and enforced by a centralized exchange</li>
</ul>
<p>You are renting exposure at a floating rate. Sometimes the rate pays you. Sometimes it taxes you. The rent is set by crowd positioning, not by a fixed schedule.</p>
<p>That is the brilliance of perps: they turn leverage into a priced commodity.</p>
</section>
<section id="closing-thoughts" class="level2">
<h2 class="anchored" data-anchor-id="closing-thoughts">Closing thoughts</h2>
<p>Perps are elegant. They solved liquidity fragmentation and roll friction with a clean and simple mechanism: no expiry, continuous mark to index, and a funding transfer that anchors price to spot.</p>
<p>But they also create a second market layered on top of price: the market for leverage. Funding is both a stabilizer and a signal, and the leverage it enables can be reflexive.</p>
<p>So next time you see a perp chart moving faster than spot, ask: is this about the asset, or is it about the cost of leverage?</p>
<p>As always, till next time.</p>
<p>JCP</p>


</section>

</main> <!-- /main -->
<script>
  <!-- A message to others like me! -->
  console.log("Nice, I also love checking on page elements!");
  console.log("If you're reading this, awesome!");
  console.log(
    "Interested in learning how to make sites like this? Check out quarto.org",
  );
  console.log("They have awesome docs and are a great place to start form!");
  console.log("Signing off. -JP");
</script>
<script>
document.addEventListener('DOMContentLoaded', function() {
  // Don't run on the main listing page
  if (document.querySelector('.quarto-listing-container-default')) {
    return;
  }

  const contentArea = document.querySelector('main#quarto-document-content');
  if (!contentArea) {
    return; // Exit if the main content area isn't found
  }

  // --- 1. GATHER METADATA ---
  const title = document.querySelector('.quarto-title.column-body h1.title')?.textContent.trim() || 'Article';
  let author = 'Josh Pearlson'; // Default author
  let date = ''; // Default date
  const url = window.location.href;

  const metaHeadings = document.querySelectorAll('.quarto-title-meta-heading');
  metaHeadings.forEach(heading => {
    const headingText = heading.textContent.trim();
    const contentsEl = heading.nextElementSibling;
    if (contentsEl && contentsEl.classList.contains('quarto-title-meta-contents')) {
      if (headingText === 'Author') {
        author = contentsEl.querySelector('p')?.textContent.trim() || author;
      }
      if (headingText === 'Published') {
        date = contentsEl.querySelector('p.date')?.textContent.trim() || date;
      }
    }
  });

  // --- 2. CREATE THE SHARE BUTTON ---
  const shareContainer = document.createElement('div');
  shareContainer.className = 'share-article-container';

  const shareButton = document.createElement('button');
  shareButton.className = 'share-article-button';
  shareButton.textContent = 'Share this Article';

  shareContainer.appendChild(shareButton);
  contentArea.appendChild(shareContainer);

  // --- 3. ADD CLICK EVENT LISTENER ---
  shareButton.addEventListener('click', function() {
    const shareText = `"${title}" by ${author} (Published: ${date}): ${url}`;

    navigator.clipboard.writeText(shareText).then(() => {
      // --- 4. PROVIDE FEEDBACK ---
      const originalText = shareButton.textContent;
      shareButton.textContent = 'Copied to clipboard!';
      shareButton.classList.add('copied');

      setTimeout(() => {
        shareButton.textContent = originalText;
        shareButton.classList.remove('copied');
      }, 3000); // Revert after 3 seconds
    }).catch(err => {
      console.error('Failed to copy text: ', err);
      // Optional: Provide error feedback to the user
      const originalText = shareButton.textContent;
      shareButton.textContent = 'Copy failed!';
      setTimeout(() => {
        shareButton.textContent = originalText;
      }, 3000);
    });
  });
});
</script>
<script>
document.addEventListener('DOMContentLoaded', function() {
  // Only run on post pages (where there is a title banner)
  if (!document.querySelector('.quarto-title-banner')) {
    return;
  }

  const mainContainer = document.querySelector('#quarto-content');
  const articleContent = mainContainer.querySelector('main#quarto-document-content');
  const headings = articleContent.querySelectorAll('h2, h3');

  if (!mainContainer || !articleContent || headings.length < 2) {
    return; // Exit if key elements are missing or not enough headings
  }

  // --- 1. CREATE THE TOC STRUCTURE ---
  const tocNav = document.createElement('nav');
  tocNav.className = 'scrollspy-nav';

  const tocList = document.createElement('ol');
  tocList.className = 'scrollspy-list';

  headings.forEach(heading => {
    if (!heading.id) {
      // Assign an ID if the heading doesn't have one
      const slug = heading.textContent.trim().toLowerCase().replace(/\s+/g, '-').replace(/[^\w-]+/g, '');
      heading.id = slug;
    }

    const tocItem = document.createElement('li');
    tocItem.className = `scrollspy-item toc-level-${heading.tagName.toLowerCase()}`;

    const tocLink = document.createElement('a');
    tocLink.href = `#${heading.id}`;
    tocLink.textContent = heading.textContent;
    tocLink.className = 'scrollspy-link';

    tocItem.appendChild(tocLink);
    tocList.appendChild(tocItem);
  });

  tocNav.appendChild(tocList);
  // Insert the ToC as the first child of the main container
  mainContainer.prepend(tocNav);

  // --- 2. SETUP INTERSECTION OBSERVER ---
  const observerOptions = {
    root: null, // relative to the viewport
    rootMargin: '0px 0px -75% 0px', // Trigger when heading is in the top 25% of the viewport
    threshold: 1.0
  };

  const observer = new IntersectionObserver((entries, obs) => {
    entries.forEach(entry => {
      const id = entry.target.getAttribute('id');
      const tocLink = document.querySelector(`.scrollspy-link[href="#${id}"]`);

      if (entry.isIntersecting && tocLink) {
        // Remove active from all, then add to the current one
        document.querySelectorAll('.scrollspy-link.active').forEach(link => link.classList.remove('active'));
        tocLink.classList.add('active');
      }
    });
  }, observerOptions);

  // Observe all the headings
  headings.forEach(heading => {
    observer.observe(heading);
  });
});
</script>
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>